!(function(e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(
        exports,
        require("@babel/runtime/helpers/defineProperty"),
        require("map-promisified")
      )
    : "function" == typeof define && define.amd
    ? define([
        "exports",
        "@babel/runtime/helpers/defineProperty",
        "map-promisified"
      ], t)
    : t(
        ((e = "undefined" != typeof globalThis ? globalThis : e || self)[
          "vue-mapbox"
        ] = {}),
        e._defineProperty,
        e["map-promisified"]
      );
})(this, function(e, t, r) {
  "use strict";
  function o(e) {
    return e && "object" == typeof e && "default" in e ? e : { default: e };
  }
  var i = o(t),
    n = o(r);
  function a(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function s(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? a(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : a(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var c,
    u = {
      methods: {
        $_emitEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$emit(e, s({ map: this.map, component: this }, t));
        },
        $_emitMapEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$_emitEvent(e.type, s({ mapboxEvent: e }, t));
        }
      }
    },
    p = {
      resize: { name: "resize" },
      webglcontextlost: { name: "webglcontextlost" },
      webglcontextrestored: { name: "webglcontextrestored" },
      remove: { name: "remove" },
      movestart: { name: "movestart" },
      load: { name: "load" },
      contextmenu: { name: "contextmenu" },
      dblclick: { name: "dblclick" },
      click: { name: "click" },
      touchcancel: { name: "touchcancel" },
      touchmove: { name: "touchmove" },
      touchend: { name: "touchend" },
      touchstart: { name: "touchstart" },
      dataloading: { name: "dataloading" },
      mousemove: { name: "mousemove" },
      mouseup: { name: "mouseup" },
      mousedown: { name: "mousedown" },
      sourcedataloading: { name: "sourcedataloading" },
      error: { name: "error" },
      data: { name: "data" },
      styledata: { name: "styledata" },
      sourcedata: { name: "sourcedata" },
      mouseout: { name: "mouseout" },
      styledataloading: { name: "styledataloading" },
      moveend: { name: "moveend" },
      move: { name: "move" },
      render: { name: "render" },
      zoom: { name: "zoom" },
      zoomstart: { name: "zoomstart" },
      zoomend: { name: "zoomend" },
      boxzoomstart: { name: "boxzoomstart" },
      boxzoomcancel: { name: "boxzoomcancel" },
      boxzoomend: { name: "boxzoomend" },
      rotate: { name: "rotate" },
      rotatestart: { name: "rotatestart" },
      rotateend: { name: "rotateend" },
      dragend: { name: "dragend" },
      drag: { name: "drag" },
      dragstart: { name: "dragstart" },
      pitch: { name: "pitch" },
      idle: { name: "idle" }
    },
    l = {
      container: {
        type: [String, HTMLElement],
        default: function() {
          return "map-".concat(("" + Math.random()).split(".")[1]);
        }
      },
      accessToken: { type: String, default: void 0 },
      minZoom: { type: Number, default: 0 },
      maxZoom: { type: Number, default: 22 },
      mapStyle: { type: [String, Object], required: !0 },
      hash: { type: [Boolean, String], default: !1 },
      interactive: { type: Boolean, default: !0 },
      bearingSnap: { type: Number, default: 7 },
      pitchWithRotate: { type: Boolean, default: !0 },
      clickTolerance: { type: Number, default: 3 },
      attributionControl: { type: Boolean, default: !0 },
      customAttribution: { type: [String, Array], default: null },
      logoPosition: {
        type: String,
        default: "bottom-left",
        validator: function(e) {
          return [
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right"
          ].includes(e);
        }
      },
      failIfMajorPerformanceCaveat: { type: Boolean, default: !1 },
      preserveDrawingBuffer: { type: Boolean, default: !1 },
      refreshExpiredTiles: { type: Boolean, default: !0 },
      maxBounds: { type: Array, default: function() {} },
      scrollZoom: {
        type: [Boolean, Object],
        default: function() {
          return !0;
        }
      },
      boxZoom: { type: Boolean, default: !0 },
      dragRotate: { type: Boolean, default: !0 },
      dragPan: { type: Boolean, default: !0 },
      keyboard: { type: Boolean, default: !0 },
      doubleClickZoom: { type: Boolean, default: !0 },
      touchZoomRotate: {
        type: [Boolean, Object],
        default: function() {
          return !0;
        }
      },
      trackResize: { type: Boolean, default: !0 },
      center: { type: [Object, Array], default: void 0 },
      zoom: { type: Number, default: 0 },
      bearing: { type: Number, default: 0 },
      pitch: { type: Number, default: 0 },
      bounds: { type: [Object, Array], default: void 0 },
      fitBoundsOptions: { type: Object, default: void 0 },
      renderWorldCopies: { type: Boolean, default: !0 },
      RTLTextPluginUrl: { type: String, default: void 0 },
      light: { type: Object, default: void 0 },
      tileBoundaries: { type: Boolean, default: !1 },
      collisionBoxes: { type: Boolean, default: !1 },
      repaint: { type: Boolean, default: !1 },
      transformRequest: { type: Function, default: null },
      maxTileCacheSize: { type: Number, default: null },
      localIdeographFontFamily: { type: String, default: null },
      collectResourceTiming: { type: Boolean, default: !1 },
      fadeDuration: { type: Number, default: 300 },
      crossSourceCollisions: { type: Boolean, default: !0 }
    },
    d = {
      maxBounds: function(e) {
        this.map.setMaxBounds(e);
      },
      minZoom: function(e) {
        this.map.setMinZoom(e);
      },
      maxZoom: function(e) {
        this.map.setMaxZoom(e);
      },
      mapStyle: function(e) {
        this.map.setStyle(e);
      },
      collisionBoxes: function(e) {
        this.map.showCollisionBoxes = e;
      },
      tileBoundaries: function(e) {
        this.map.showTileBoundaries = e;
      },
      repaint: function(e) {
        this.map.repaint = e;
      },
      zoom: function(e) {
        this.map.setZoom(e);
      },
      center: function(e) {
        this.map.setCenter(e);
      },
      bearing: function(e) {
        this.map.setBearing(e);
      },
      pitch: function(e) {
        this.map.setPitch(e);
      },
      light: function(e) {
        this.map.setLigh(e);
      }
    };
  function h(e, t, r, o) {
    var i = this;
    this.initial ||
      (this.$listeners["update:".concat(e)]
        ? (this.propsIsUpdating[e]
            ? ((this._watcher.active = !1),
              this.$nextTick(function() {
                i._watcher.active = !0;
              }))
            : ((this._watcher.active = !0), t(r, o)),
          (this.propsIsUpdating[e] = !1))
        : t(r, o));
  }
  function m(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function f(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? m(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : m(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function y(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function b(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? y(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : y(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function v(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  var g = {
    name: "GlMap",
    mixins: [
      {
        watch:
          ((c = {}),
          Object.entries(d).forEach(function(e) {
            c[e[0]] = function(t, r) {
              return h.call(this, e[0], e[1].bind(this), t, r);
            };
          }),
          c)
      },
      {
        created: function() {
          this.actions = {};
        },
        methods: {
          $_registerAsyncActions: function(e) {
            this.actions = b(
              b({}, n.default(e)),
              {},
              {
                stop: function() {
                  var e = this;
                  this.map.stop();
                  var t = {
                    pitch: this.map.getPitch(),
                    zoom: this.map.getZoom(),
                    bearing: this.map.getBearing(),
                    center: this.map.getCenter()
                  };
                  return (
                    Object.entries(t).forEach(function(t) {
                      e.$_updateSyncedPropsFabric(t[0], t[1])();
                    }),
                    Promise.resolve(t)
                  );
                }
              }
            );
          }
        }
      },
      {
        methods: {
          $_updateSyncedPropsFabric: function(e, t) {
            var r = this;
            return function() {
              r.propsIsUpdating[e] = !0;
              var o = "function" == typeof t ? t() : t;
              return r.$emit("update:".concat(e), o);
            };
          },
          $_bindPropsUpdateEvents: function() {
            var e = this;
            [
              {
                events: ["moveend"],
                prop: "center",
                getter: this.map.getCenter.bind(this.map)
              },
              {
                events: ["zoomend"],
                prop: "zoom",
                getter: this.map.getZoom.bind(this.map)
              },
              {
                events: ["rotate"],
                prop: "bearing",
                getter: this.map.getBearing.bind(this.map)
              },
              {
                events: ["pitch"],
                prop: "pitch",
                getter: this.map.getPitch.bind(this.map)
              },
              {
                events: ["moveend", "zoomend", "rotate", "pitch"],
                prop: "bounds",
                getter: function() {
                  var t = e.map.getBounds();
                  return (
                    e.$props.bounds instanceof Array && (t = t.toArray()), t
                  );
                }
              }
            ].forEach(function(t) {
              var r = t.events,
                o = t.prop,
                i = t.getter;
              r.forEach(function(t) {
                e.$listeners["update:".concat(o)] &&
                  e.map.on(t, e.$_updateSyncedPropsFabric(o, i));
              });
            });
          },
          $_loadMap: function() {
            var e = this;
            return this.mapboxPromise.then(function(t) {
              return (
                (e.mapbox = t.default ? t.default : t),
                new Promise(function(t) {
                  e.accessToken && (e.mapbox.accessToken = e.accessToken);
                  var r = new e.mapbox.Map(
                    f(
                      f({}, e._props),
                      {},
                      { container: e.$refs.container, style: e.mapStyle }
                    )
                  );
                  r.on("load", function() {
                    return t(r);
                  });
                })
              );
            });
          },
          $_RTLTextPluginError: function(e) {
            this.$emit("rtl-plugin-error", { map: this.map, error: e });
          },
          $_bindMapEvents: function(e) {
            var t = this;
            Object.keys(this.$listeners).forEach(function(r) {
              e.includes(r) && t.map.on(r, t.$_emitMapEvent);
            });
          },
          $_unbindEvents: function(e) {
            var t = this;
            e.forEach(function(e) {
              t.map.off(e, t.$_emitMapEvent);
            });
          }
        }
      },
      u
    ],
    props: (function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? v(Object(r), !0).forEach(function(t) {
              i.default(e, t, r[t]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : v(Object(r)).forEach(function(t) {
              Object.defineProperty(
                e,
                t,
                Object.getOwnPropertyDescriptor(r, t)
              );
            });
      }
      return e;
    })({ mapboxGl: { type: Object, default: null } }, l),
    provide: function() {
      var e = this;
      return {
        get mapbox() {
          return e.mapbox;
        },
        get map() {
          return e.map;
        },
        get actions() {
          return e.actions;
        }
      };
    },
    data: function() {
      return { initial: !0, initialized: !1 };
    },
    computed: {
      loaded: function() {
        return !!this.map && this.map.loaded();
      },
      version: function() {
        return this.map ? this.map.version : null;
      },
      isStyleLoaded: function() {
        return !!this.map && this.map.isStyleLoaded();
      },
      areTilesLoaded: function() {
        return !!this.map && this.map.areTilesLoaded();
      },
      isMoving: function() {
        return !!this.map && this.map.isMoving();
      },
      canvas: function() {
        return this.map ? this.map.getCanvas() : null;
      },
      canvasContainer: function() {
        return this.map ? this.map.getCanvasContainer() : null;
      },
      images: function() {
        return this.map ? this.map.listImages() : null;
      }
    },
    created: function() {
      (this.map = null),
        (this.propsIsUpdating = {}),
        (this.$_containerVNode = null),
        (this.mapboxPromise = this.mapboxGl
          ? Promise.resolve(this.mapboxGl)
          : import("mapbox-gl"));
    },
    mounted: function() {
      var e = this;
      this.$_loadMap().then(function(t) {
        (e.map = t),
          void 0 !== e.RTLTextPluginUrl &&
            "loaded" !== e.mapbox.getRTLTextPluginStatus() &&
            e.mapbox.setRTLTextPlugin(
              e.RTLTextPluginUrl,
              e.$_RTLTextPluginError
            );
        var r = Object.keys(p);
        e.$_bindMapEvents(r),
          e.$_registerAsyncActions(t),
          e.$_bindPropsUpdateEvents(),
          (e.initial = !1),
          (e.initialized = !0),
          e.$emit("load", { map: t, component: e });
      });
    },
    beforeDestroy: function() {
      var e = this;
      this.$nextTick(function() {
        e.map && e.map.remove();
      });
    },
    render: function(e) {
      return (
        this.$$_containerVNode ||
          (this.$_containerVNode = e("div", {
            id: this.container,
            ref: "container"
          })),
        e("div", { class: "mgl-map-wrapper" }, [
          this.$_containerVNode,
          this.initialized ? this.$slots.default : null
        ])
      );
    }
  };
  function O(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function j(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? O(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : O(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var $ = {
      methods: {
        $_emitSelfEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$_emitMapEvent(e, j({ control: this.control }, t));
        },
        $_bindSelfEvents: function(e, t) {
          var r = this;
          Object.keys(this.$listeners).forEach(function(o) {
            e.includes(o) && t.on(o, r.$_emitSelfEvent);
          });
        },
        $_unbindSelfEvents: function(e, t) {
          var r = this;
          0 !== e.length &&
            t &&
            e.forEach(function(e) {
              t.off(e, r.$_emitSelfEvent);
            });
        }
      }
    },
    w = {
      mixins: [u, $],
      inject: ["mapbox", "map", "actions"],
      props: { position: { type: String, default: "top-right" } },
      beforeDestroy: function() {
        this.map && this.control && this.map.removeControl(this.control);
      },
      methods: {
        $_addControl: function() {
          try {
            this.map.addControl(this.control, this.position);
          } catch (e) {
            return void this.$_emitEvent("error", { error: e });
          }
          this.$_emitEvent("added", { control: this.control });
        }
      },
      render: function() {}
    },
    P = {
      name: "NavigationControl",
      mixins: [w],
      props: {
        showCompass: { type: Boolean, default: !0 },
        showZoom: { type: Boolean, default: !0 }
      },
      created: function() {
        (this.control = new this.mapbox.NavigationControl(this.$props)),
          this.$_addControl();
      }
    },
    S = {
      trackuserlocationstart: "trackuserlocationstart",
      trackuserlocationend: "trackuserlocationend",
      geolocate: "geolocate",
      error: "error"
    },
    _ = {
      name: "GeolocateControl",
      mixins: [u, $, w],
      props: {
        positionOptions: {
          type: Object,
          default: function() {
            return { enableHighAccuracy: !1, timeout: 6e3 };
          }
        },
        fitBoundsOptions: {
          type: Object,
          default: function() {
            return { maxZoom: 15 };
          }
        },
        trackUserLocation: { type: Boolean, default: !1 },
        showUserLocation: { type: Boolean, default: !0 }
      },
      created: function() {
        var e = this.mapbox.GeolocateControl;
        (this.control = new e(this.$props)),
          this.$_addControl(),
          this.$_bindSelfEvents(Object.keys(S), this.control);
      },
      methods: {
        trigger: function() {
          if (this.control) return this.control.trigger();
        }
      }
    },
    E = {
      name: "FullscreenControl",
      mixins: [w],
      props: { container: { type: HTMLElement, default: void 0 } },
      created: function() {
        (this.control = new this.mapbox.FullscreenControl(this.$props)),
          this.$_addControl();
      }
    },
    I = {
      name: "AttributionControl",
      mixins: [w],
      props: {
        compact: { type: Boolean, default: !0 },
        customAttribution: { type: [String, Array], deafault: void 0 }
      },
      created: function() {
        (this.control = new this.mapbox.AttributionControl(this.$props)),
          this.$_addControl();
      }
    },
    L = {
      name: "ScaleControl",
      mixins: [w],
      props: {
        maxWidth: { type: Number, default: 150 },
        unit: {
          type: String,
          default: "metric",
          validator: function(e) {
            return ["imperial", "metric", "nautical"].includes(e);
          }
        }
      },
      watch: {
        unit: function(e, t) {
          this.control && e !== t && this.control.setUnit(e);
        }
      },
      created: function() {
        (this.control = new this.mapbox.ScaleControl(this.$props)),
          this.$_addControl();
      }
    };
  function x(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  var k = { drag: "drag", dragstart: "dragstart", dragend: "dragend" },
    M = { click: "click", mouseenter: "mouseenter", mouseleave: "mouseleave" },
    D = {
      name: "MapMarker",
      mixins: [u, $],
      inject: ["mapbox", "map"],
      provide: function() {
        var e = this;
        return {
          get marker() {
            return e.marker;
          }
        };
      },
      props: {
        offset: {
          type: [Object, Array],
          default: function() {
            return [0, 0];
          }
        },
        coordinates: { type: Array, required: !0 },
        color: { type: String },
        anchor: { type: String, default: "center" },
        draggable: { type: Boolean, default: !1 }
      },
      data: function() {
        return { initial: !0, marker: void 0 };
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.marker.setLngLat(e);
        },
        draggable: function(e) {
          this.initial || this.marker.setDraggable(e);
        }
      },
      mounted: function() {
        var e = this,
          t = (function(e) {
            for (var t = 1; t < arguments.length; t++) {
              var r = null != arguments[t] ? arguments[t] : {};
              t % 2
                ? x(Object(r), !0).forEach(function(t) {
                    i.default(e, t, r[t]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(r)
                  )
                : x(Object(r)).forEach(function(t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(r, t)
                    );
                  });
            }
            return e;
          })({}, this.$props);
        this.$slots.marker && (t.element = this.$slots.marker[0].elm),
          (this.marker = new this.mapbox.Marker(t)),
          this.$listeners["update:coordinates"] &&
            this.marker.on("dragend", function(t) {
              var r;
              (r =
                e.coordinates instanceof Array
                  ? [t.target._lngLat.lng, t.target._lngLat.lat]
                  : t.target._lngLat),
                e.$emit("update:coordinates", r);
            });
        var r = Object.keys(k);
        this.$_bindSelfEvents(r, this.marker),
          (this.initial = !1),
          this.$_addMarker();
      },
      beforeDestroy: function() {
        void 0 !== this.map && void 0 !== this.marker && this.marker.remove();
      },
      methods: {
        $_addMarker: function() {
          this.marker.setLngLat(this.coordinates).addTo(this.map),
            this.$_bindMarkerDOMEvents(),
            this.$_emitEvent("added", { marker: this.marker });
        },
        $_emitSelfEvent: function(e) {
          this.$_emitMapEvent(e, { marker: this.marker });
        },
        $_bindMarkerDOMEvents: function() {
          var e = this;
          Object.keys(this.$listeners).forEach(function(t) {
            Object.values(M).includes(t) &&
              e.marker._element.addEventListener(t, function(t) {
                e.$_emitSelfEvent(t);
              });
          });
        },
        remove: function() {
          this.marker.remove(), this.$_emitEvent("removed");
        },
        togglePopup: function() {
          return this.marker.togglePopup();
        }
      },
      render: function(e) {
        return e("div", { style: { display: "none" } }, [
          this.$slots.marker,
          this.marker ? this.$slots.default : null
        ]);
      }
    },
    C = { open: "open", close: "close" },
    B = {
      name: "Popup",
      mixins: [u, $],
      inject: {
        mapbox: { default: null },
        map: { default: null },
        marker: { default: null }
      },
      props: {
        closeButton: { type: Boolean, default: !0 },
        closeOnClick: { type: Boolean, default: !0 },
        anchor: {
          validator: function(e) {
            return (
              "string" == typeof e &&
              [
                "top",
                "bottom",
                "left",
                "right",
                "top-left",
                "top-right",
                "bottom-left",
                "bottom-right"
              ].includes(e)
            );
          },
          default: void 0
        },
        offset: {
          type: [Number, Object, Array],
          default: function() {
            return [0, 0];
          }
        },
        coordinates: { type: Array },
        onlyText: { type: Boolean, default: !1 },
        showed: { type: Boolean, default: !1 }
      },
      data: function() {
        return { initial: !0, popup: void 0 };
      },
      computed: {
        open: {
          get: function() {
            return void 0 !== this.popup && this.popup.isOpen();
          },
          set: function(e) {
            this.map &&
              this.popup &&
              (e ? this.popup.addTo(this.map) : this.popup.remove());
          }
        }
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.popup.setLngLat(e);
        },
        showed: function(e, t) {
          e !== t &&
            ((this.open = e), this.marker && this.marker.togglePopup());
        }
      },
      created: function() {
        this.popup = new this.mapbox.Popup(this.$props);
      },
      mounted: function() {
        this.$_addPopup(), (this.initial = !1);
      },
      beforeDestroy: function() {
        this.map && (this.popup.remove(), this.$_emitEvent("removed"));
      },
      methods: {
        $_addPopup: function() {
          if (
            ((this.popup = new this.mapbox.Popup(this.$props)),
            void 0 !== this.coordinates &&
              this.popup.setLngLat(this.coordinates),
            void 0 !== this.$slots.default)
          )
            if (this.onlyText)
              if (3 === this.$slots.default[0].elm.nodeType) {
                var e = document.createElement("span");
                e.appendChild(this.$slots.default[0].elm),
                  this.popup.setText(e.innerText);
              } else this.popup.setText(this.$slots.default[0].elm.innerText);
            else this.popup.setDOMContent(this.$slots.default[0].elm);
          this.$_bindSelfEvents(Object.keys(C), this.popup),
            this.$_emitEvent("added", { popup: this.popup }),
            this.marker && this.marker.setPopup(this.popup),
            this.showed &&
              ((this.open = !0), this.marker && this.marker.togglePopup());
        },
        $_emitSelfEvent: function(e) {
          this.$_emitMapEvent(e, { popup: this.popup });
        },
        remove: function() {
          this.popup.remove(),
            this.$_emitEvent("remove", { popup: this.popup });
        }
      },
      render: function(e) {
        return e("div", { style: { display: "none" } }, [this.$slots.default]);
      }
    },
    T = [
      "mousedown",
      "mouseup",
      "click",
      "dblclick",
      "mousemove",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "contextmenu",
      "touchstart",
      "touchend",
      "touchcancel"
    ];
  function z(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function F(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? z(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : z(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var A = {
      layerId: { type: String, required: !0 },
      layer: { type: Object, required: !0 },
      before: { type: String, default: void 0 }
    },
    R = {
      clearSource: { type: Boolean, default: !0 },
      replaceSource: { type: Boolean, default: !1 },
      replace: { type: Boolean, default: !1 }
    },
    Z = {
      mixins: [u],
      props: F(
        F(
          F(
            {},
            {
              sourceId: { type: String, required: !0 },
              source: { type: [Object, String], default: void 0 }
            }
          ),
          A
        ),
        R
      ),
      inject: ["mapbox", "map"],
      data: function() {
        return { initial: !0 };
      },
      computed: {
        sourceLoaded: function() {
          return !!this.map && this.map.isSourceLoaded(this.sourceId);
        },
        mapLayer: function() {
          return this.map ? this.map.getLayer(this.layerId) : null;
        },
        mapSource: function() {
          return this.map ? this.map.getSource(this.sourceId) : null;
        }
      },
      created: function() {
        this.layer.minzoom &&
          this.$watch("layer.minzoom", function(e) {
            this.initial ||
              this.map.setLayerZoomRange(this.layerId, e, this.layer.maxzoom);
          }),
          this.layer.maxzoom &&
            this.$watch("layer.maxzoom", function(e) {
              this.initial ||
                this.map.setLayerZoomRange(this.layerId, this.layer.minzoom, e);
            }),
          this.layer.paint &&
            this.$watch(
              "layer.paint",
              function(e) {
                if (!this.initial && e)
                  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
                    var o = r[t];
                    this.map.setPaintProperty(this.layerId, o, e[o]);
                  }
              },
              { deep: !0 }
            ),
          this.layer.layout &&
            this.$watch(
              "layer.layout",
              function(e) {
                if (!this.initial && e)
                  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
                    var o = r[t];
                    this.map.setLayoutProperty(this.layerId, o, e[o]);
                  }
              },
              { deep: !0 }
            ),
          this.layer.filter &&
            this.$watch(
              "layer.filter",
              function(e) {
                this.initial || this.map.setFilter(this.layerId, e);
              },
              { deep: !0 }
            );
      },
      beforeDestroy: function() {
        if (this.map && this.map.loaded()) {
          try {
            this.map.removeLayer(this.layerId);
          } catch (e) {
            this.$_emitEvent("layer-does-not-exist", {
              layerId: this.sourceId,
              error: e
            });
          }
          if (this.clearSource)
            try {
              this.map.removeSource(this.sourceId);
            } catch (e) {
              this.$_emitEvent("source-does-not-exist", {
                sourceId: this.sourceId,
                error: e
              });
            }
        }
      },
      methods: {
        $_emitLayerMapEvent: function(e) {
          return this.$_emitMapEvent(e, { layerId: this.layerId });
        },
        $_bindLayerEvents: function(e) {
          var t = this;
          Object.keys(this.$listeners).forEach(function(r) {
            e.includes(r) && t.map.on(r, t.layerId, t.$_emitLayerMapEvent);
          });
        },
        $_unbindEvents: function(e) {
          var t = this;
          this.map &&
            e.forEach(function(e) {
              t.map.off(e, t.layerId, t.$_emitLayerMapEvent);
            });
        },
        $_watchSourceLoading: function(e) {
          "source" === e.dataType &&
            e.sourceId === this.sourceId &&
            (this.$_emitEvent("layer-source-loading", {
              sourceId: this.sourceId
            }),
            this.map.off("dataloading", this.$_watchSourceLoading));
        },
        move: function(e) {
          this.map.moveLayer(this.layerId, e),
            this.$_emitEvent("layer-moved", {
              layerId: this.layerId,
              beforeId: e
            });
        },
        remove: function() {
          this.map.removeLayer(this.layerId),
            this.map.removeSource(this.sourceId),
            this.$_emitEvent("layer-removed", { layerId: this.layerId }),
            this.$destroy();
        }
      },
      render: function() {}
    };
  function N(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function q(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? N(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : N(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function U(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function G(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? U(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : U(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function V(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function H(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? V(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : V(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function W(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function J(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? W(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : W(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function K(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function Q(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? K(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : K(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function X(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      t &&
        (o = o.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, o);
    }
    return r;
  }
  function Y(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? X(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : X(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var ee = u,
    te = $,
    re = w,
    oe = Z,
    ie = { withEvents: u, withSelfEvents: $, asControl: w, asLayer: Z },
    ne = g,
    ae = P,
    se = _,
    ce = E,
    ue = I,
    pe = L,
    le = {
      name: "GeojsonLayer",
      mixins: [Z],
      computed: {
        getSourceFeatures: function() {
          var e = this;
          return function(t) {
            return e.map
              ? e.map.querySourceFeatures(e.sourceId, { filter: t })
              : null;
          };
        },
        getRenderedFeatures: function() {
          var e = this;
          return function(t, r) {
            return e.map
              ? e.map.queryRenderedFeatures(t, {
                  layers: [e.layerId],
                  filter: r
                })
              : null;
          };
        },
        getClusterExpansionZoom: function() {
          var e = this;
          return function(t) {
            return new Promise(function(r, o) {
              if (!e.mapSource)
                return o(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              e.mapSource.getClusterExpansionZoom(t, function(e, t) {
                return e ? o(e) : r(t);
              });
            });
          };
        },
        getClusterChildren: function() {
          var e = this;
          return function(t) {
            return new Promise(function(r, o) {
              var i = e.mapSource;
              if (!i)
                return o(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              i.getClusterChildren(t, function(e, t) {
                return e ? o(e) : r(t);
              });
            });
          };
        },
        getClusterLeaves: function() {
          var e = this;
          return function() {
            for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
              r[o] = arguments[o];
            return new Promise(function(t, o) {
              if (!e.mapSource)
                return o(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              var i;
              (i = e.mapSource).getClusterLeaves.apply(
                i,
                r.concat([
                  function(e, r) {
                    return e ? o(e) : t(r);
                  }
                ])
              );
            });
          };
        }
      },
      created: function() {
        this.source &&
          this.$watch(
            "source.data",
            function(e) {
              this.initial || this.mapSource.setData(e);
            },
            { deep: !0 }
          ),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          if (
            (this.map.on("dataloading", this.$_watchSourceLoading), this.source)
          ) {
            var e = q({ type: "geojson" }, this.source);
            try {
              this.map.addSource(this.sourceId, e);
            } catch (t) {
              this.replaceSource &&
                (this.map.removeSource(this.sourceId),
                this.map.addSource(this.sourceId, e));
            }
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(T),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = q({ id: this.layerId, source: this.sourceId }, this.layer);
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        },
        setFeatureState: function(e, t) {
          if (this.map) {
            var r = { id: e, source: this.source };
            return this.map.setFeatureState(r, t);
          }
        },
        getFeatureState: function(e) {
          if (this.map) {
            var t = { id: e, source: this.source };
            return this.map.getFeatureState(t);
          }
        },
        removeFeatureState: function(e, t, r) {
          if (this.map) {
            var o = { id: e, source: this.source, sourceLayer: t };
            return this.map.removeFeatureState(o, r);
          }
        }
      }
    },
    de = {
      name: "ImageLayer",
      mixins: [Z],
      created: function() {
        this.source &&
          (this.source.coordinates &&
            this.$watch(
              "source.coordinates",
              function(e) {
                this.initial || (e && this.mapSource.setCoordinates(e));
              },
              { deep: !0 }
            ),
          this.source.url &&
            this.$watch(
              "source.url",
              function(e) {
                this.initial ||
                  (e &&
                    this.mapSource.updateImage({
                      url: e,
                      coordinates: this.source.coordinates
                    }));
              },
              { deep: !0 }
            )),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = G({ type: "image" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(T), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = G(
            { id: this.layerId, source: this.sourceId, type: "raster" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    he = {
      name: "CanvasLayer",
      mixins: [Z],
      inject: ["mapbox", "map"],
      props: {
        source: { type: Object, required: !0 },
        layer: { type: Object, default: null }
      },
      computed: {
        canvasElement: function() {
          return this.mapSource ? this.mapSource.getCanvas() : null;
        }
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.mapSource.setCoordinates(e);
        }
      },
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = H({ type: "canvas" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(T), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = H(
            { id: this.layerId, source: this.sourceId, type: "raster" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", {
              layerId: this.layerId,
              canvas: this.canvasElement
            });
        }
      }
    },
    me = {
      name: "VideoLayer",
      mixins: [Z],
      computed: {
        video: function() {
          return this.map.getSource(this.sourceId).getVideo();
        }
      },
      created: function() {
        this.source &&
          this.source.coordinates &&
          this.$watch("source.coordinates", function(e) {
            this.initial || this.mapSource.setCoordinates(e);
          }),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = J({ type: "video" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(T), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = J(
            { id: this.layerId, source: this.sourceId, type: "background" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    fe = {
      name: "VectorLayer",
      mixins: [Z],
      computed: {
        getSourceFeatures: function() {
          var e = this;
          return function(t) {
            return e.map
              ? e.map.querySourceFeatures(e.sourceId, {
                  sourceLayer: e.layer["source-layer"],
                  filter: t
                })
              : null;
          };
        },
        getRenderedFeatures: function() {
          var e = this;
          return function(t, r) {
            return e.map
              ? e.map.queryRenderedFeatures(t, {
                  layers: [e.layerId],
                  filter: r
                })
              : null;
          };
        }
      },
      watch: {
        filter: function(e) {
          this.initial || this.map.setFilter(this.layerId, e);
        }
      },
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = Q({ type: "vector" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(T),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = Q({ id: this.layerId, source: this.sourceId }, this.layer);
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        },
        setFeatureState: function(e, t) {
          if (this.map) {
            var r = {
              id: e,
              source: this.sourceId,
              "source-layer": this.layer["source-layer"]
            };
            return this.map.setFeatureState(r, t);
          }
        },
        getFeatureState: function(e) {
          if (this.map) {
            var t = {
              id: e,
              source: this.source,
              "source-layer": this.layer["source-layer"]
            };
            return this.map.getFeatureState(t);
          }
        }
      }
    },
    ye = {
      name: "RasterLayer",
      mixins: [Z],
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = Y({ type: "raster" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(T),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = Y(
            { id: this.layerId, type: "raster", source: this.sourceId },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    be = D,
    ve = B;
  (e.$helpers = ie),
    (e.MglAttributionControl = ue),
    (e.MglCanvasLayer = he),
    (e.MglFullscreenControl = ce),
    (e.MglGeojsonLayer = le),
    (e.MglGeolocateControl = se),
    (e.MglImageLayer = de),
    (e.MglMap = ne),
    (e.MglMarker = be),
    (e.MglNavigationControl = ae),
    (e.MglPopup = ve),
    (e.MglRasterLayer = ye),
    (e.MglScaleControl = pe),
    (e.MglVectorLayer = fe),
    (e.MglVideoLayer = me),
    (e.asControl = re),
    (e.asLayer = oe),
    (e.withEvents = ee),
    (e.withSelfEvents = te),
    Object.defineProperty(e, "__esModule", { value: !0 });
});
